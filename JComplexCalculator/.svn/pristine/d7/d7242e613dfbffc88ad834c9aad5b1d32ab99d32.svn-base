package mkz.cc.core.equation.function;

import java.util.ArrayList;
import java.util.HashMap;

import mkz.cc.core.equation.Equation;
import mkz.cc.core.equation.IFunction;
import mkz.cc.util.IO;
import mkz.cc.util.Pair;

public class FunctionPool // XXX could do extends HashMap..
{
	private static FunctionPool instance = new FunctionPool();

	private HashMap<String, Pair<String, IFunction>> mFunctions = new HashMap<String, Pair<String, IFunction>>();

	// The function definition statements (e.g. {"f","f(x):=2x"})
	private HashMap<String, String> mFunctionConstructors = new HashMap<String, String>();

	private FunctionPool()
	{
		_initDefaultFunctions(mFunctions);
	}

	public static FunctionPool getInstance()
	{
		return instance;
	}

	public Equation getFuncion(String aCallName)
	{
		Pair<String, IFunction> lFcn = mFunctions.get(aCallName);
		return lFcn != null ? new Equation(lFcn.getObject1(), lFcn.getObject2()) : null;
	}

	public boolean addFunction(String aCallName, String aDisplayName, ArrayList<String> aParamNames, String aCreateStatement, LinearParamEquation aFunction)
	{
		if (!mFunctions.containsKey(aCallName))
		{
			ParamFunction lFunction = new ParamFunction(aDisplayName, aParamNames, aFunction);
			mFunctions.put(aCallName, new Pair<String, IFunction>(aDisplayName, lFunction));
			mFunctionConstructors.put(aCallName, aCreateStatement);
			return true;
		}

		return false;

	}

	private static boolean _initDefaultFunctions(HashMap<String, Pair<String, IFunction>> aFunctions)
	{
		try
		{
			aFunctions.put(CallNames.SUM, new Pair<String, IFunction>(Equation.DisplayNames.SUM, DefaultFunctions.SUM));
			aFunctions.put(CallNames.EXP, new Pair<String, IFunction>(Equation.DisplayNames.EXP, DefaultFunctions.EXP));
			aFunctions.put(CallNames.LOG, new Pair<String, IFunction>(Equation.DisplayNames.LOG, DefaultFunctions.LOG));
			aFunctions.put(CallNames.SIN, new Pair<String, IFunction>(Equation.DisplayNames.SIN, DefaultFunctions.SIN));
			aFunctions.put(CallNames.COS, new Pair<String, IFunction>(Equation.DisplayNames.COS, DefaultFunctions.COS));
			aFunctions.put(CallNames.TAN, new Pair<String, IFunction>(Equation.DisplayNames.TAN, DefaultFunctions.TAN));
			aFunctions.put(CallNames.COT, new Pair<String, IFunction>(Equation.DisplayNames.COT, DefaultFunctions.COT));
			aFunctions.put(CallNames.ASIN, new Pair<String, IFunction>(Equation.DisplayNames.ASIN, DefaultFunctions.ASIN));
			aFunctions.put(CallNames.ACOS, new Pair<String, IFunction>(Equation.DisplayNames.ACOS, DefaultFunctions.ACOS));
			aFunctions.put(CallNames.ATAN, new Pair<String, IFunction>(Equation.DisplayNames.ATAN, DefaultFunctions.ATAN));
			aFunctions.put(CallNames.ACOT, new Pair<String, IFunction>(Equation.DisplayNames.ACOT, DefaultFunctions.ACOT));
			IO.SysOutD("Default functions loaded.");
			return true;
		}
		catch (Exception e)
		{
			IO.SysOutE(e);
			return false;
		}
	}

	private static class CallNames
	{
		public static final String SUM = "sum";
		public static final String EXP = "exp";
		public static final String LOG = "log";

		public static final String SIN = "sin";
		public static final String COS = "cos";
		public static final String TAN = "tan";
		public static final String COT = "cot";

		public static final String ASIN = "asin";
		public static final String ACOS = "acos";
		public static final String ATAN = "atan";
		public static final String ACOT = "acot";
	}

}
