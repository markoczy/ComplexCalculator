/**
 * File: JComplexCalculator::LogicalDefinitionParser.java
 * 
 * Copyright (C) 2016  Aleistar Markóczy
 * 
 * This file is part of JComplexCalculator.
 *
 * JComplexCalculator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * JComplexCalculator is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with JComplexCalculator.  If not, see <http://www.gnu.org/licenses/>.
 */
package mkz.cc.logical.parser;

import java.util.ArrayList;
import java.util.Arrays;

import mkz.cc.core.debug.parser.ParserException;
import mkz.cc.core.equation.Constant;
import mkz.cc.core.equation.Equation;
import mkz.cc.core.equation.definition.IEquation;
import mkz.cc.core.equation.function.Variable;
import mkz.cc.core.parser.ParserCursor;
import mkz.cc.core.parser.ParserTools;
import mkz.cc.logical.LogicalEquationFactory;
import mkz.cc.logical.equation.LinearLogicalEquation;
import mkz.cc.logical.equation.ParamLinearLogicalEquation;
import mkz.cc.util.IO;

/**
 * The Class LogicalDefinitionParser.
 */
public class LogicalDefinitionParser extends LogicalEquationParser
{
	/** The member cursor. */
	ParserCursor mCursor=null;
	
	ArrayList<String> mParamNames=new ArrayList<String>();
	
	/**
	 * Parses the equation. Returns verity table as 2D boolean array.
	 * Example use: '(a,b,c)->a&!b|c'
	 *
	 * @param aEquation the reference equation
	 * @return the boolean[][]
	 * @throws ParserException 
	 */
	public ArrayList<ArrayList<Boolean>> parseDefinition(String aEquation) throws ParserException
	{
		mParamNames=parseVariableNames(aEquation);
		
		int lPos=aEquation.indexOf("->");
		if(lPos==-1)
		{
			IO.SysOutE("Definition sign '->' not found, exiting..");
			return null;
		}
		
		mCursor=new ParserCursor(lPos+2);
		IEquation<Boolean> lParsedParamEq=_parseEquation(aEquation, mCursor);
		
		if(!(lParsedParamEq instanceof ParamLinearLogicalEquation))
		{
			IO.SysOutE("Implementation fault, Equation is not a Parametrizable Logical equation, type: "+ lParsedParamEq.getClass().getCanonicalName());
			return null;
		}
		
		ParamLinearLogicalEquation lParamEq = (ParamLinearLogicalEquation)lParsedParamEq;
		Equation<Boolean> lFunctionEq= LogicalEquationFactory.createDefinitionEquation(aEquation, mParamNames, lParamEq);
		
		
		ArrayList<ArrayList<Boolean>> lTable = _getInputTable(mParamNames.size());
		
		for(ArrayList<Boolean> iRow:lTable)
		{
			ArrayList<IEquation<Boolean>> lParams=new ArrayList<IEquation<Boolean>>();
			for(Boolean iVal:iRow)
			{
				lParams.add(new Constant<Boolean>(iVal));
			}
			lFunctionEq.setParams(lParams);
			
			iRow.add(lFunctionEq.getValue());
		}
		
		
//		lEq.getValue();
//		try
//		{
//			IO.SysOutV("TestVal: "+lEq.getValue());
//		}
//		catch (CCalcException e)
//		{
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		for(ArrayList<Boolean> iRow:lTable)
		{
			StringBuilder sb = new StringBuilder();
			for(Boolean iVal:iRow) sb.append(""+iVal+"\t");
			
			IO.SysOutV("Row: "+sb.toString());
		}
		

		
		return lTable;
	}
	
	
	/**
	 * Parses the variable names. e.g.: '(a,b)->a&b' returns {a,b} 
	 *
	 * @return the array list
	 */
	public static ArrayList<String> parseVariableNames(String aEquation)
	{
		ParserCursor lCursor = new ParserCursor();
		
		// it's allowed to define params with or without '()'
		//
		if(lCursor.get(aEquation)=='(')
		{
			IO.SysOutV("Skipped first par open");
			lCursor.next();
		}
		
		String lParamStr = new String();
		
		boolean lExit=false;
		while(!lExit)
		{
			lParamStr+=lCursor.get(aEquation);
			lCursor.next();
			
			if(!lCursor.exceeds(aEquation))
			{
				lExit|=lCursor.get(aEquation)==')';
				lExit|=lCursor.get(aEquation)=='-';
			}
			else lExit=true;
		}
		
		if(lParamStr.length()!=0)
		{
			return new ArrayList<String>(Arrays.asList(lParamStr.split(",")));
		}
		
		return null;
	}
	
	@Override
	protected IEquation<Boolean> _getInversion(IEquation<Boolean> aEquation)
	{
		return LogicalEquationFactory.createParamInversion(aEquation);
	}
	
	@Override
	protected LinearLogicalEquation _getNewEquation()
	{
		return new ParamLinearLogicalEquation();
	}
	
	@Override
	protected IEquation<Boolean> _parseAlphabetic(String equation, ParserCursor aCursor) throws ParserException
	{
		String lName = ParserTools.parseIdentifier(equation, aCursor,false);
		
		for(String iParam:mParamNames)if(iParam.equals(lName))
		{
			IO.SysOutV("Found param '"+lName+"'");
			return new Variable<Boolean>(lName);
		}
		
		return super._parseAlphabetic(equation, aCursor);
	}
	
	
	public ArrayList<ArrayList<Boolean>> _getInputTable(int aVarCount)
	{
		int lPossibilities = 1;
		for(int i=0;i<aVarCount;i++) lPossibilities*=2;
		IO.SysOutV("Possibilities = "+lPossibilities);
		
		ArrayList<ArrayList<Boolean>> rVal = new ArrayList<ArrayList<Boolean>>();
		
		int[] lMods = new int[aVarCount];
		
		for(int i = 0;i<aVarCount;i++)
		{
			int lVal=1;
			for(int j=0;j<(aVarCount-i-1);j++) lVal*=2;
			
			lMods[i]=lVal;
			IO.SysOutV("lMods["+i+"]="+lMods[i]);
		}

		// init as '000000..'
		ArrayList<Boolean> lRow = new ArrayList<Boolean>();
		for(int i=0;i<aVarCount;i++) lRow.add(false);
		
		rVal.add(lRow);
		
		for(int i = 1; i<lPossibilities;i++)
		{
			lRow = new ArrayList<Boolean>(lRow); // -> and fixed
			
			for(int iMod=0;iMod<lMods.length;iMod++)
			{
				if(i%lMods[iMod]==0) lRow.set(iMod, !lRow.get(iMod));
			}
			
			rVal.add(lRow);
		}
		
		for(ArrayList<Boolean> iRow:rVal)
		{
			StringBuilder sb = new StringBuilder();
			for(Boolean iVal:iRow) sb.append(""+iVal+"\t");
			
			IO.SysOutV("Row: "+sb.toString());
		}
		
		
		return rVal;
	}
	
//	// TODO outsource gfx...
//	protected ArrayList<String> _getHeaderRows()
//	{
//		if(mParamNames==null)
//		{
//			IO.SysOutE("Cannot create Header, no params found.");
//			return null;
//		}
//		
//		StringBuilder lRow1=new StringBuilder();
//		StringBuilder lRow2=new StringBuilder();
//		
//		lRow1.append("+");
//		lRow2.append("|");
//		
//		for(String iParamName:mParamNames)
//		{
//			lRow1.append('-');
//			for(int i=0;i<iParamName.length();i++)
//			{ 
//				lRow1.append('-');
//			}
//			// ' ' & '|' 
//			lRow1.append('-');
//			lRow1.append('-');
//			
//			
//			lRow2.append(' ');
//			lRow2.append(iParamName);
//			lRow2.append(' ');
//			lRow2.append('|');
//			
//		}
//		
//		lRow1.append('-');
//		for(int i=0;i<RESULT_STRING.length();i++)
//		{ 
//			lRow1.append('-');
//		}
//		lRow1.append('-');
//		
//		lRow2.append(' ');
//		lRow2.append(RESULT_STRING);
//		lRow2.append(' ');
//		lRow2.append('|');
//		lRow1.append("+");
//		
//		ArrayList<String> rVal = new ArrayList<String>();
//		
//		rVal.add(lRow1.toString());
//		rVal.add(lRow2.toString());
//		rVal.add(lRow1.toString());
//		
//		return rVal;
//	}
//	
//	protected ArrayList<String> _getBodyRows(ArrayList<ArrayList<Boolean>> aParams)
//	{
//		ArrayList<Integer> lOffsetsLeft = new ArrayList<Integer>();
//		ArrayList<Integer> lOffsetsRight = new ArrayList<Integer>();
//		
//		for(String iParamName:mParamNames)
//		{
//			lOffsetsRight.add((int)(iParamName.length()/2));
//			lOffsetsLeft.add(iParamName.length()-(int)(iParamName.length()/2)-1);
//		}
//		lOffsetsRight.add((int)(RESULT_STRING.length()/2));
//		lOffsetsLeft.add(RESULT_STRING.length()-(int)(RESULT_STRING.length()/2)-1);
//		
////		for(Integer iOffLeft:lOffsetsLeft) IO.SysOutV("Offset left: "+iOffLeft);
////		for(Integer iOffRight:lOffsetsRight) IO.SysOutV("Offset right: "+iOffRight);
//		
//		
//		ArrayList<String> rVal = new ArrayList<String>();
//		
//		for(int iRow=0;iRow<aParams.size();iRow++)
//		{
//			StringBuilder lRowStr = new StringBuilder();
//			lRowStr.append('|');
//			for(int iCol=0;iCol<aParams.get(iRow).size();iCol++)
//			{
//				lRowStr.append(' ');
//				for(int iOffL=0;iOffL<lOffsetsLeft.get(iCol);iOffL++)lRowStr.append(' ');
//				
//				lRowStr.append(""+(aParams.get(iRow).get(iCol)==true?1:0));
//				
//				for(int iOffR=0;iOffR<lOffsetsRight.get(iCol);iOffR++)lRowStr.append(' ');
//				
//				lRowStr.append(' ');
//				lRowStr.append('|');
//			}
//			
//			rVal.add(lRowStr.toString());
//		}
//		
//		
//		return rVal;
//	}
}
