/**
 * File: CCalcJavaV2::LinearEquation.java
 *
 * Copyright (C) 2016  Aleistar Markóczy, a.markoczy@gmail.com
 * 
 */
package mkz.cc.core.equation.linear;

import java.util.ArrayList;

import mkz.cc.core.debug.CCalcException;
import mkz.cc.core.equation.Equation;
import mkz.cc.core.equation.EquationFactory;
import mkz.cc.core.equation.Operation;
import mkz.cc.core.equation.definition.IEquation;
import mkz.cc.util.IO;


/**
 * The Class LinearEquation. Implements an array of LinearOperation elements that is solved in a 
 * predefined order ("^" before "/" before "*" before "-" before "+")
 */
public class LinearEquation implements IEquation
{
	
	/** The member operations. */
	private ArrayList<LinearOperation> mOperations = new ArrayList<LinearOperation>();
	
	/**
	 * Instantiates a new linear equation.
	 */
	public LinearEquation()
	{
	}
	
	/**
	 * Adds the operation.
	 *
	 * @param aEquation the reference equation
	 * @param aOperation the reference operation
	 */
	public void addOperation(IEquation aEquation, Operation aOperation)
	{
		mOperations.add(new LinearOperation(aEquation, aOperation));
	}

	/* (non-Javadoc)
	 * @see mkz.cc.core.equation.IEquation#getValue()
	 */
	@Override
	public double getValue() throws CCalcException
	{
		int lPos=0;
		while((lPos=_getFirstOf(mOperations,Operation.EXP))!=-1)
		{
			IO.SysOutV("Solving "+Operation.EXP);
			_solveOp(mOperations,lPos);
		}
		
		while((lPos=_getFirstOf(mOperations,Operation.DIV))!=-1)
		{
			IO.SysOutV("Solving "+Operation.DIV);
			_solveOp(mOperations,lPos);
		}
		
		while((lPos=_getFirstOf(mOperations,Operation.MPL))!=-1)
		{
			IO.SysOutV("Solving "+Operation.MPL);
			_solveOp(mOperations,lPos);
		}
		
		while((lPos=_getFirstOf(mOperations,Operation.SUB))!=-1)
		{
			IO.SysOutV("Solving "+Operation.SUB);
			_solveOp(mOperations,lPos);
		}
		
		while((lPos=_getFirstOf(mOperations,Operation.ADD))!=-1)
		{
			IO.SysOutV("Solving "+Operation.ADD);
			_solveOp(mOperations,lPos);
		}
		
		
		if(mOperations.size()>1) IO.SysOutE("Operations size too big: "+mOperations.size());
		return mOperations.get(0).getEquation().getValue();
	}
	
	
	/**
	 * _get first of.
	 *
	 * @param aOpArr the reference op array
	 * @param aOperation the reference operation
	 * @return the int
	 */
	private static int _getFirstOf(ArrayList<LinearOperation> aOpArr,Operation aOperation)
	{
		for(int i = 0;i<aOpArr.size();i++)
		{
			if(aOpArr.get(i).getOperation().equals(aOperation)) return i;
		}
		
		return -1;
	}
	
	/**
	 * _solve op.
	 *
	 * @param aOpArr the reference op array
	 * @param index the index
	 * @return true, if successful
	 */
	private static boolean _solveOp(ArrayList<LinearOperation> aOpArr,int index)
	{
		if(aOpArr.size()-1<index)
		{
			IO.SysOutE("Wrong index, is "+index+", should be >"+(aOpArr.size()-1));
		}
		
		// get current linear operation
		LinearOperation lLinOp1=aOpArr.get(index);
		LinearOperation lLinOp2=aOpArr.get(index+1);
		
		// create the new equation (2 + 4 => eq(2,4,ADD))
		Equation lEquation=EquationFactory.createBasicEquation(lLinOp1.getOperation());
		lEquation.addParam(lLinOp1.getEquation());
		lEquation.addParam(lLinOp2.getEquation());
		
		// create new linear operation element ( 2+4-.. -> (2+4)- )
		LinearOperation lNewOp = new LinearOperation(lEquation,lLinOp2.getOperation());
		aOpArr.set(index, lNewOp);
		aOpArr.remove(index+1);
		
		return true;
	}
	
}
