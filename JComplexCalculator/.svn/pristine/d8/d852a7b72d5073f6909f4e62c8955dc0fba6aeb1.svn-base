package mkz.cc.core.equation.linear;

import java.util.ArrayList;

import mkz.cc.core.debug.CCalcException;
import mkz.cc.core.equation.Equation;
import mkz.cc.core.equation.EquationFactory;
import mkz.cc.core.equation.IEquation;
import mkz.cc.core.equation.Operation;
import mkz.cc.util.IO;


public class LinearEquation implements IEquation
{
	private ArrayList<LinearOperation> mOperations = new ArrayList<LinearOperation>();
	
	public LinearEquation()
	{
	}
	
	public void addOperation(IEquation aEquation, Operation aOperation)
	{
		mOperations.add(new LinearOperation(aEquation, aOperation));
	}

	@Override
	public double getValue() throws CCalcException
	{
		int lPos=0;
		while((lPos=_getFirstOf(mOperations,Operation.EXP))!=-1)
		{
			IO.SysOutV("Solving "+Operation.EXP);
			_solveOp(mOperations,lPos);
		}
		
		while((lPos=_getFirstOf(mOperations,Operation.DIV))!=-1)
		{
			IO.SysOutV("Solving "+Operation.DIV);
			_solveOp(mOperations,lPos);
		}
		
		while((lPos=_getFirstOf(mOperations,Operation.MPL))!=-1)
		{
			IO.SysOutV("Solving "+Operation.MPL);
			_solveOp(mOperations,lPos);
		}
		
		while((lPos=_getFirstOf(mOperations,Operation.SUB))!=-1)
		{
			IO.SysOutV("Solving "+Operation.SUB);
			_solveOp(mOperations,lPos);
		}
		
		while((lPos=_getFirstOf(mOperations,Operation.ADD))!=-1)
		{
			IO.SysOutV("Solving "+Operation.ADD);
			_solveOp(mOperations,lPos);
		}
		
		
		if(mOperations.size()>1) IO.SysOutE("Operations size too big: "+mOperations.size());
		return mOperations.get(0).getEquation().getValue();
	}
	
	
	private static int _getFirstOf(ArrayList<LinearOperation> aOpArr,Operation aOperation)
	{
		for(int i = 0;i<aOpArr.size();i++)
		{
			if(aOpArr.get(i).getOperation().equals(aOperation)) return i;
		}
		
		return -1;
	}
	
	private static boolean _solveOp(ArrayList<LinearOperation> aOpArr,int index)
	{
		if(aOpArr.size()-1<index)
		{
			IO.SysOutE("Wrong index, is "+index+", should be >"+(aOpArr.size()-1));
		}
		
		// get current linear operation
		LinearOperation lLinOp1=aOpArr.get(index);
		LinearOperation lLinOp2=aOpArr.get(index+1);
		
		// create the new equation (2 + 4 => eq(2,4,ADD))
		Equation lEquation=EquationFactory.createBasicEquation(lLinOp1.getOperation());
		lEquation.addParam(lLinOp1.getEquation());
		lEquation.addParam(lLinOp2.getEquation());
		
		// create new linear operation element ( 2+4-.. -> (2+4)- )
		LinearOperation lNewOp = new LinearOperation(lEquation,lLinOp2.getOperation());
		aOpArr.set(index, lNewOp);
		aOpArr.remove(index+1);
		
		return true;
	}
	
}
